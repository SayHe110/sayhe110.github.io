<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="LeiJian"><title>缓存 Redis 常见问题 · LeiJian</title><meta name="description" content="为什么使用缓存？因为传统的关系型数据库已经不能适应所有的场景了，如秒杀，当访问流量达到高峰时，不使用缓存中间件，那么流量会打入数据库，很容易打崩数据库，所以这种的场景下需要引入缓存中间件；因为缓存中间件如Redis为内存型缓存中间件，单线程，处理速度比MySQL快几十倍甚至上百倍，所以常用的数据或者"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7706e2ba8c658f563720bb36e8a87962";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">LeiJian<p>PHP Engineer</p></a></h3></div></div><ul class="social-links"><li><a href="http://github.com/sayhe110"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于我</a></li><li><a href="/archives">归档</a></li><li><a href="/links">链接</a></li><li><a href="/reading">阅读</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>缓存 Redis 常见问题</a></h3></div><div class="post-content"><h3 id="为什么使用缓存？"><a href="#为什么使用缓存？" class="headerlink" title="为什么使用缓存？"></a>为什么使用缓存？</h3><p>因为传统的关系型数据库已经不能适应所有的场景了，如秒杀，当访问流量达到高峰时，不使用缓存中间件，那么流量会打入数据库，很容易打崩数据库，所以这种的场景下需要引入缓存中间件；因为缓存中间件如Redis为内存型缓存中间件，单线程，处理速度比MySQL快几十倍甚至上百倍，所以常用的数据或者临时数据都可以使用缓存来进行提升性能。常见的如Redis、Memcached，考虑到他们的优缺点，最终选择Redis作为缓存中间件。</p>
<h3 id="Redis-与-Memcached-的比较？"><a href="#Redis-与-Memcached-的比较？" class="headerlink" title="Redis 与 Memcached 的比较？"></a>Redis 与 Memcached 的比较？</h3><h5 id="Memcached特点："><a href="#Memcached特点：" class="headerlink" title="Memcached特点："></a>Memcached特点：</h5><p>多线程异步IO、仅支持K/V类型的数据、没有持久化</p>
<h5 id="Redis特点："><a href="#Redis特点：" class="headerlink" title="Redis特点："></a>Redis特点：</h5><p>单线程异步IO、不仅支持K/V类型数据结构，还有其他的数据结构，如Hash、List等等、支持持久化</p>
<h3 id="Redis基础类型"><a href="#Redis基础类型" class="headerlink" title="Redis基础类型"></a>Redis基础类型</h3><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><p>最常用的数据类型，内部由SDS（Simple Dynamic String 简单动态字符串）进行实现（好处是可以通过预分配冗余空间的方式减少内存的频繁分配），常用于缓存简单字符串，计数器，共享用户 session</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><p>将结构化的数据缓存在 redis 中，每次读写缓存的只会就操作 Hash 里的某个字段</p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>list 为有序列表，常用于列表型数据结构，例如粉丝列表，文章评论列表，还可以做简单的消息队列</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>无序集合，存入的数据自动去重，对于两集合交集、并集、差集处理速度更快，常用于例如朋友圈，查看朋友圈时，能看到朋友的朋友有些是自己共同的，只有自己共同的好友，朋友圈的评论点赞才会被看到</p>
<h5 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h5><p>有序集合，存入数据自动去重，根据 score 进行排序，常用于排行榜相关场景</p>
<h3 id="做一个简单的消息队列，以及做一个延时消息队列？"><a href="#做一个简单的消息队列，以及做一个延时消息队列？" class="headerlink" title="做一个简单的消息队列，以及做一个延时消息队列？"></a>做一个简单的消息队列，以及做一个延时消息队列？</h3><p>简单的消息队列可以通过list数据结构做，通过 rpush 生产消息，lpop 消费消息，当没有消息时进行 sleep，也可以通过 blpop 进行阻塞式获取消息，当没有消息时进行阻塞，直到获取到消息。</p>
<p>延时消息队列可以通过有序集合（sorted set）数据结构做，将时间戳作为 score 值，通过轮训获得 N 秒前的消息。</p>
<p>还可以通过 pub/sub 进行做 1：N的消息队列，缺点就是消费者下线时，这段时间的消息是获取不到的。</p>
<h3 id="Redis-的高级用法"><a href="#Redis-的高级用法" class="headerlink" title="Redis 的高级用法"></a>Redis 的高级用法</h3><h5 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h5><p>位图支持 bit 位来存储信息，可以通过 bitmap 实现布隆过滤器（BloomFilter）</p>
<h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><p>提供大规模数据去重统计，如UV</p>
<h5 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h5><p>发布与订阅功能，制作简单的消息队列</p>
<h5 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h5><p>保存地理位置，并做位置距离计算以及两点之间的距离</p>
<h5 id="lua、pipeline"><a href="#lua、pipeline" class="headerlink" title="lua、pipeline"></a>lua、pipeline</h5><p>没用过，就不做介绍</p>
<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>redis 也支持事务，redis 只能保证串行执行命令，并且能保证全部执行，若命令执行失败了，并不会回滚，还是会继续执行下去，官方好像并不推荐使用事务</p>
<h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>redis 持久化可以分为 AOF，RDB两种持久化方式<br>AOF：AOF机制对每条写入命令作为日志，以追加（append-only）模式写入日志文件中，所以没有磁盘寻址开销就很快，redis 重启后默认会使用 AOF 进行数据恢复，因为比 RDB 数据更加完整<br>RDB：对redis的数据进行周期性持久化，多久持久化一次取决于配置<br>两种方式都可以把数据持久化到磁盘上，RDB更适合做冷备份，AOF 更适合做热备份。</p>
<p>优缺点：<br>AOF：<br>    AOF为每秒都通过后台的线程 fsync 操作，那最多就丢失一秒的数据，因为AOF对日志文件是追加方式的记录，所以免去的磁盘寻址的开销，增加写入效率，缺点是相同的数据，AOF文件比RDB还要大<br>RDB：<br>    RDB为某一时刻Redis数据的快照，RDB对Redis的性能影响非常小，是因为在同步数据的时候他只fork了一个子进程进行持久化，而且在数据恢复方面比AOF快很多，缺点是数据的完整性肯定不如AOF的，还有就是假如在同步数据时文件很大，客户端会有短暂的卡顿，假如系统正在进行大规模操作数据，那么RDB fork 的子进程会生成非常大的快照。</p>
<p>两者之间的选择：<br>应该一起用，在RDB快照这段时间，采用AOF进行数据补全，这样就性能达到较高，系统也更加健壮</p>
<h3 id="Redis-保证集群的高可用"><a href="#Redis-保证集群的高可用" class="headerlink" title="Redis 保证集群的高可用"></a>Redis 保证集群的高可用</h3><p>通过哨兵集群（sentinal），哨兵必须通过三个实例来保证自己的健壮性，如果是两个的话，那就达不到高可用</p>
<p>假如是两个哨兵，当master挂了，那就剩下一个子节点了，没有哨兵去允许故障转移了，所以最好的状态是有三个哨兵，当master挂了，那么就选举出一个节点来执行故障转移。</p>
<h3 id="Redis-的主从同步"><a href="#Redis-的主从同步" class="headerlink" title="Redis 的主从同步"></a>Redis 的主从同步</h3><p>单机的QPS是有限的，不可能让主节点又读又写，但是只让master去写，子节点去读，分担了读请求那就会好很多。</p>
<p>之间的数据是如何同步的：<br>当启动子节点时，他会发送一个命令给master，假如是第一次连接master，他会触发一个全量复制，master会启动一个线程，生成RDB快照，还会把新的请求写入内存中，RDB完成后，master会将这个文件发送给子节点，子节点拿到后将RDB文件内容写入磁盘，然后加载到内存，完成后master再将内存中的新请求都发送给子节点。</p>
<h3 id="Redis-的内存淘汰机制"><a href="#Redis-的内存淘汰机制" class="headerlink" title="Redis 的内存淘汰机制"></a>Redis 的内存淘汰机制</h3><p>redis 过期策略是定期删除+惰性删除</p>
<p>定期删除就是每100ms就随机抽查设置了过期时间的key，过期就删，惰性删除就是每次取key的时候，判断过期时间，过期了就删。</p>
<p>为什么不是扫描所有key呢，和MySQL扫描全表问题一样，压力过大。</p>
<p>假如没过期也没查询到，redis 还提供了其他内存淘汰机制，两个方面：从所有key考虑，从设置过期时间考虑<br>volatile-lru(已设置过期时间lru)、volatile-ttl(已设置过期时间，即将过期的数据)、volatile-random(已过期时间随机删)<br>allkeys-lru(所有keylru)、allkeys-random(所有数据随机删)</p>
<h3 id="缓存场景问题"><a href="#缓存场景问题" class="headerlink" title="缓存场景问题"></a>缓存场景问题</h3><h4 id="更新方式问题"><a href="#更新方式问题" class="headerlink" title="更新方式问题"></a>更新方式问题</h4><p>假如数据源是DB，则在更新完DB则直接更新缓存，假如数据源是远程服务，对key进行设置失效时间+允许数据不一致时间，在获取新数据时，再对key 进行更新，当远程服务失效了，那么就还继续使用旧数据，直到远程服务恢复</p>
<h4 id="缓存雪崩、击穿、穿透"><a href="#缓存雪崩、击穿、穿透" class="headerlink" title="缓存雪崩、击穿、穿透"></a>缓存雪崩、击穿、穿透</h4><p>缓存的雪崩：大面积key失效导致，例如大量key在某一时段过期，那么这段时间缓存是不可用的，这时所有请求都会到DB上，可以通过主从模式或者集群模式来保证缓存的高可用</p>
<p>缓存的穿透：用户查询缓存中不存在的内容，例如id，程序没有过滤 -1 的情况，缓存中不存在，那么请求就会到DB上，假如请求量过大，DB也会挂掉，可以通过程序的健壮性来去除，还可以通过增加布隆过滤器来避免这样的问题</p>
<p>缓存的击穿：和雪崩类似，某一热点key在某一时段过期，那么这段时间热点key是不可用的，请求会到DB上，可以通过避免热点key在某一时段一起失效，在设置过期时间时增加一点随机值。</p>
<blockquote>
<p>以上的Redis相关问题是我在面试的这段时间中总结，当做个记录</p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-26</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://blog.sayhe110.cn/2020/03/26/缓存-Redis-常见问题/,LeiJian,缓存 Redis 常见问题,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/03/26/MySQL-面试常见问题/" title="MySQL 面试常见问题">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/12/10/遇到-DDOS/" title="遇到 DDOS">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>